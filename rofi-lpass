#!/bin/bash
set -e
set -o pipefail
PS4='+ $(date "+%s.%N") (${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

SELF_CMD=$(basename "$0")

SESSION_TYPE=x11
CAN_TYPE=false
if [[ -n "$WAYLAND_DISPLAY" ]]; then
  SESSION_TYPE=wayland
  export LPASS_CLIPBOARD_COMMAND=wl-copy
  if hash wtype; then
    CAN_TYPE=true
  fi
  # If wl-paste is running with cliphist, we should not use --paste-once and
  # instead show dialog window so that cliphist wrapper can avoid adding the
  # password to the history, based on the focused window title.
  if pgrep --list-full 'wl-paste' | grep -Eq '\--watch .*cliphist'; then
    PASTE_ONCE=''
    SHOW_DIALOG=1
  else
    # paste-once should work fine without a clipboard history manager
    PASTE_ONCE='--paste-once'
    SHOW_DIALOG=0
  fi
else
  if hash xvkbd || hash xdotool; then
    CAN_TYPE=true
  fi
fi

print-account-list() {
  lpass ls --format "%/as%ag - %an (%au) [%ai]" 2>&1
}

type-account-field() {
  # Close stdout and stderr to stop this process from dying when the parent ends
  exec 1>/dev/null 2>/dev/null

  local value
  value=$(lpass show --quiet -j "$1" | jq ".[0][\"$2\"]" -r)
  case "$SESSION_TYPE" in
  x11)
    if hash xvkbd 2>/dev/null; then
      xvkbd -xsendevent -text "$value"
    else
      local active_window
      active_window=$(xdotool getactivewindow)
      xdotool windowactivate --sync "$active_window" type --clearmodifiers "$value"
    fi
    ;;
  wayland)
    wtype "$value"
    ;;
  esac
}

# Initialize the progress dialog PID to 0, and the FIFO path to an empty string
# Will be set by return value of show-progress-dialog if SHOW_DIALOG is set
DIALOG_PID=0
PROGRESS_FIFO='' # Will be set when we create the FIFO

# kill-progress-dialog will kill the progress dialog and remove the FIFO if they still exist
# @param dialog_pid PID of the progress dialog
# @return 0 (success), 1 (failure)
kill-progress-dialog() {
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ]; then
    local dialog_pid="$1"
    if [ -n "$dialog_pid" ] && [ "$dialog_pid" -gt 1 ] && kill -0 "$dialog_pid" &>/dev/null; then
      kill "$dialog_pid" &>/dev/null || kill -9 "$dialog_pid" &>/dev/null
    fi
    [ -n "$PROGRESS_FIFO" ] && [ -p "$PROGRESS_FIFO" ] && rm -f "$PROGRESS_FIFO"
    [ -n "$PROGRESS_FIFO" ] && [[ "$(dirname "$PROGRESS_FIFO")" != '.' ]] && [ -d "$(dirname "$PROGRESS_FIFO")" ] && rmdir "$(dirname "$PROGRESS_FIFO")"
  fi
}

# Show a progress dialog while copying sensitive data to the clipboard
# @discussion This function will create a FIFO and progress dialog (via `yad`),
#   then write to it to update the progress dialog to 98% before returning it to
#   STDOUT.  The progress dialog will close itself after 5 seconds, when ESC is
#   pressed, when the window is unfocused, or when 100 is written to the FIFO.
# @output Progress dialog FIFO path, PID of the dialog process
#   (space-separated STDOUT)
# @return 0 (success), 1 (failure)
show-progress-dialog() {
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ]; then
    local progress_fifodir progress_pid progress_fifo
    progress_fifodir="$(mktemp -d /tmp/rofi-lpass.XXXXXXXXXX)" || {
      echo "Failed to create temp dir" >&2
      return 1
    }
    progress_fifo="$(mktemp -p "$progress_fifodir/" -u "yad-fifo.XXXXXXXXXX")" || {
      echo "Failed to create progress fifo" >&2
      return 1
    }
    mkfifo "$progress_fifo" || {
      echo "Failed to create progress fifo" >&2
      return 1
    }

    PROGRESS_FIFO="$progress_fifo"

    # Both should exit on their own, but return the PIDs just in case.
    # The FIFO write will block unless there is a reader, and yad dialog reader
    # will stop script execution until it is closed, so we need to run both
    # in the background
    (
      # Close stdout and stderr of this subshell to avoid waiting for any output
      exec 1>/dev/null 2>/dev/null

      # Setup a trap to cleanup the FIFO and temp dir when this subshell
      # coprocess exits. This is a subshell, which inherits the non-exported
      # global vars due to `fork()` so we only need to set the variable above
      # for the trap handler within this subshell.
      #
      # References:
      #   - https://unix.stackexchange.com/a/138498/7688
      #   - https://stackoverflow.com/a/51903792/645491

      # Trap on EXIT also to cleanup everything when the subshell exits
      trap 'kill-progress-dialog "$DIALOG_PID"' INT TERM HUP EXIT

      tail -f "$progress_fifo" |
        yad --progress --icon=lock \
          --title='rofi-lpass: Added sensitive text to clipboard' \
          --text='Adding sensitive info to clipboard' \
          --image=lock --buttons-layout=center --escape-ok \
          --progress-text='Copying: ' --auto-close --align=center --text-align=center
    ) &
    dialog_pid="$!"
    disown $dialog_pid

    (
      echo "BEGIN: for loop writing to FIFO" >&2
      exec 1>/dev/null 2>/dev/null
      for i in $(seq 1 99); do
        stdbuf -oL echo "$i" >"$progress_fifo"
        sleep 0.02703454873737373737
      done
    ) &
    progress_pid="$!"
    disown $progress_pid

    echo -n "$progress_fifo $dialog_pid $progress_pid" >&1
    return 0
  fi
  return 1
}

WATCH_CLIPBOARD_PID=0
# Kill the background process watching the clipboard for the password
# @param watch_clipboard_pid PID of the background process watching the clipboard
# @return 0 (success), 1 (failure)
# @discussion This function will kill the background `wl-paste --watch` process
# that is watching the clipboard and launching `finalize-progress-dialog` when
# the clipboard changes.
kill-watch-clipboard() {
  local watch_clipboard_pid
  watch_clipboard_pid="$1"
  if [ -n "$watch_clipboard_pid" ] && [ "$watch_clipboard_pid" -gt 1 ] && kill -0 "$watch_clipboard_pid" &>/dev/null; then
    kill "$watch_clipboard_pid" &>/dev/null || kill -9 "$watch_clipboard_pid" &>/dev/null || return 1
    return 0
  fi
  return 1
}

# Start a background process to watch the clipboard for the password
# and close the dialog when it is found
# @param pw_cksum CRC of the password to be shielded by the dialog window
# @return 0 (success), 1 (failure)
# @discussion This function starts a background wl-paste process to watch the
# clipboard, and launch this script with the finalize-progress-dialog function.
# That function will close the dialog when a checksum of the password we expect
# is found to match the clipboard contents.
start-watch-clipboard() {
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ]; then
    local me pw_cksum
    me="$(realpath "$0")" # Path of this script
    pw_cksum="$1"
    # Start a background process to watch the clipboard for the password
    # and close the dialog when it is found
    # This should ensure that the dialog lives long enough to shield the
    # password from cliphist
    (
      echo "BEGIN: start-watch-clipboard" >&2
      exec 1>/dev/null 2>/dev/null
      # The non-exported global variables are accessible in the subshell, due to
      # `fork()`.  The trap will need these.  We want to cleanup the dialog and
      # FIFO when the `wl-paste` and this subshell fork process is killed. Note
      # that the code here enclosed within `()` parentheses is a subshell.  Also
      # note that the `finalize-progress-dialog()` function is called in a
      # separate shell process (via `fork()` + `execve()`), so we need to pass
      # these variables in the subshell to be accessible in the
      # `finalize-progress-dialog()` function's co-process bash interpreter
      # environment.

      # Trap on EXIT also to cleanup everything when this `wl-paste` subshell exits
      trap 'kill-progress-dialog "$DIALOG_PID"' INT TERM HUP EXIT
      # finalize-progress-dialog(dialog_pid, progress_pid, progress_fifo, ppid_fifo, pw_cksum)

      # Note: We are re-entrant here, but all global variable state is lost in
      # the new shell, so we need to pass them as arguments
      wl-paste --watch "$me" finalize-progress-dialog "$DIALOG_PID" "$PROGRESS_PID" "$PROGRESS_FIFO" "$pw_cksum" 1>&2 2>>/tmp/rofi-lpass-wl-paste-watch.log
    ) &
    self_fork_pid="$!"
    disown $self_fork_pid
    echo "Started wl-paste --watch in subshell with PID $self_fork_pid" >&2
    WATCH_CLIPBOARD_PID="$self_fork_pid"
    return 0
  fi
  return 1
}

# Update the progress dialog with a new value
# @param new_value New value to update the progress dialog with
# @return 0 (success), 1 (failure)

# @discussion This function will update the progress dialog with a new value,
# using line-buffered output to the FIFO. If the progress subshell PID is still
# running, it will be killed before updating the FIFO with a new progress value.
# If the progress dialog FIFO is not found, it will cleanup exit.
update-progress-dialog() {
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ]; then
    local new_value
    new_value="$1"
    echo "Updating progress dialog to $new_value" >&2
    if kill -0 "$PROGRESS_PID" 2>/dev/null; then
      echo "BEFORE writing '$new_value' - KILLING Progress PID $PROGRESS_PID !!" >&2
      kill "$PROGRESS_PID" 2>/dev/null || kill -9 "$PROGRESS_PID" 2>/dev/null || true
    fi

    if [ -n "$PROGRESS_FIFO" ] && [ -p "$PROGRESS_FIFO" ]; then
      echo "Writing '$new_value' to FIFO $PROGRESS_FIFO" >&2
      stdbuf -oL echo "$new_value" >"$PROGRESS_FIFO"
      return 0
    else
      echo "Progress FIFO not found, exiting" >&2
      # Handle case where dialog was dismissed early and PROGRESS_FIFO is gone.
      # Avoid leaving `wl-paste --watch` process running if `$PROGRESS_FIFO` is
      # not found.  In this case, we should assume that `kill-progress-dialog()`
      # has been called, either in `trap` or elsewhere.
      kill-watch-clipboard "$WATCH_CLIPBOARD_PID"
      return 1
    fi
  fi
}

# Close the progress dialog by updating it to 100%
# To be run by wl-paste --watch after the password is in the clipboard
# @param dialog_pid PID of the progress dialog
# @param progress_pid PID of the progress dialog's progress writer
# @param progress_fifo Path to the progress dialog's FIFO
# @param pw_cksum CRC of the password to be shielded by the dialog window
# @return 0 (success), 1 (failure)
# @discussion This function will check that the password found in clipboard
# matches the one we just copied, then sleep for a moment and update the
# progress dialog to 100%
finalize-progress-dialog() {
  local dialog_pid progress_pid progress_fifo pw_cksum ppid retval
  dialog_pid="$1"
  progress_pid="$2"
  progress_fifo="$3"
  pw_cksum="${*:4}"

  # Get the parent PID of this script, should be the PID of: wl-paste --watch
  ppid="$(ps -o ppid= -p "$$" | awk '{ print $1 }' )"
  ps -o cmd -p "$ppid" | grep -q 'wl-paste --watch' || {
    echo "Not running in wl-paste --watch, exiting" >&2
    return 1
  }
  # We must set this here because we are in a separate shell process invocation,
  # not a `fork()`-ed subshell!
  WATCH_CLIPBOARD_PID="$ppid"

  # Process the entire STDIN stream with cksum and store the output
  cksum_output=$(cat - | cksum 2>/dev/null)

  # Extract the cksum value
  cksum_value=$(echo "$cksum_output" | cut -d ' ' -f 1)

  echo "Given Password Checksum: $pw_cksum" >&2
  echo "wl-paste output cksum: $cksum_output" >&2
  echo "wl-paste cksum value: $cksum_value" >&2

  echo "Checking clipboard for password match: $pw_cksum == $cksum_value ?" >&2
  if [[ "$pw_cksum" == "$cksum_value" ]]; then
    local sleep_interval max_sleep_time_limit count loop_iter_limit
    # echo "Checksum match found" >&2
    # Wait for the cliphist store wrapper script to end
    # This will ensure that the dialog is closed after the password is in the clipboard
    sleep_interval=0.000010 # 10 μs (microseconds) - Only supported in GNU sleep
    max_sleep_time_limit=10 # 10 seconds - Maximum time to wait
    count=0
    # Shell arithmetic rounds down e.g. floor(), and also results in floating
    # point error with microsecond precision, so we need to use `bc`
    # how many iterations to wait
    loop_iter_limit=$(echo "scale=0; $max_sleep_time_limit / $sleep_interval" | bc)

    while [ "$count" -lt "$loop_iter_limit" ] && ! cliphist_pid=$(pgrep --full '^bash.*\.local/share/sway/scripts/cliphist store' 2>/dev/null) ; do
      # Waiting for cliphist store to start
      sleep $sleep_interval
      count=$((count + 1))
    done
    if [ -n "$cliphist_pid" ] && [ "$cliphist_pid" -gt 1 ]; then
      # Wait for cliphist store to end
      inotifywait --timeout 10 --event CLOSE "/proc/$cliphist_pid/fd/0"
      retval=0
    else
      echo "cliphist store PID not found within $max_sleep_time_limit seconds" >&2
      retval=1
    fi


    sleep 1 # Wait slightly after cliphist store to see the focused dialog window
    # Set global variables to cleanup the dialog & background processes
    # This function is only run by wl-paste --watch, in a separate shell process
    # so we need to set these
    PROGRESS_FIFO="$progress_fifo"
    PROGRESS_PID="$progress_pid"
    DIALOG_PID="$dialog_pid"
    SHOW_DIALOG=1

    # Update the progress dialog to 100% to close it
    echo "Updating progress dialog to 100%" >&2
    # If FIFO is not found, this will cleanup the dialog and our parent
    # `wl-paste --watch` process
    update-progress-dialog '100'

    # Cleanup the dialog and FIFO
    [ "$DIALOG_PID" -ne 0 ] && kill-progress-dialog "$DIALOG_PID"
    # We are the last process in the chain, so we need to kill the parent
    # The parent process of this script, is the `wl-paste --watch` process
    kill-watch-clipboard "$WATCH_CLIPBOARD_PID"

    return $retval
  else
    echo "No checksum match found" >&2
    # Avoid killing the dialog, and cleaning up the FIFO because we have not
    # found the password in the clipboard this time
    DIALOG_PID=0
    PROGRESS_FIFO=''
    return 1
  fi

}

copy-account-field() {
  echo "BEGIN copy-account-field" >&2
  local wl_copy_pid show_dialog_output copying_sensitive_data process_newlines

  # Initialize
  copying_sensitive_data=0
  process_newlines="tr -d '\n'"

  # Note: This does not do anything with wl-copy, but we will use it anyway in
  # case it supports this in the future
  if [[ "${2}" =~ "password" ]]; then
    export CLIPBOARD_STATE=sensitive
  elif [[ "${2}" =~ "note" ]]; then
    export CLIPBOARD_STATE=sensitive
    process_newlines=cat
  fi

  # Only show progress / "security screen" dialog if copying a password AND SHOW_DIALOG is set
  # Effectively, this will only show the dialog if copying a password AND on Wayland with cliphist running
  # For example with: wl-paste --watch cliphist store
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ] && [ -n "$CLIPBOARD_STATE" ] && [ "$CLIPBOARD_STATE" == "sensitive" ]; then
    copying_sensitive_data=1
  fi

  if [ "$copying_sensitive_data" -eq 1 ]; then
    # Set the `lpass` clipboard command to wl-copy, and clear the clipboard
    # after 30 seconds.
    # This is only used when passing `--clip` or `-c` to `lpass`.
    export LPASS_CLIPBOARD_COMMAND='/usr/bin/wl-copy && ( sleep 30 && /usr/bin/wl-copy --clear) & disown'
    # Capture the output from show-progress-dialog
    show_dialog_output="$(show-progress-dialog)"
    PROGRESS_FIFO="$(echo -n "$show_dialog_output" | cut -d' ' -f1)"
    DIALOG_PID="$(echo -n "$show_dialog_output" | cut -d ' ' -f2)"
    PROGRESS_PID="$(echo -n "$show_dialog_output" | cut -d ' ' -f3)"

    # Now you have both the FIFO path and PID captured
    echo "FIFO Path: $PROGRESS_FIFO" >&2
    echo "Dialog PID: $DIALOG_PID" >&2
    echo "Progress PID: $PROGRESS_PID" >&2
  fi

  case "$SESSION_TYPE" in
  x11)
    lpass show --quiet -j "$1" | jq ".[0][\"$2\"]" -r | $process_newlines | xsel -ib -t 30000
    ;;
  wayland)
    if [ "$copying_sensitive_data" -eq 1 ]; then
      # Create a named pipe for cksum output, only stored in SHM virtual in-memory filesystem
      cksum_pipe_pattern="/dev/shm/cksum_pipe.$$.XXXXXXXXX"
      cksum_pipe="$(mktemp -u "$cksum_pipe_pattern")"
      mkfifo "$cksum_pipe"

      # Use tee to send a copy of the output to cksum, processed through the named
      # pipe.  This will allow us to never store the password in a variable, and
      # only use the fast CRC checksum to compare the expected values in the
      # coprocess spawned by wl-paste --watch running the finalize-progress-dialog
      # function.
      # Directly include the tee command in the pipeline when copying sensitive data
      # shellcheck disable=SC2086
      (
        lpass show --quiet -j "$1" | jq ".[0][\"$2\"]" -r | $process_newlines | stdbuf -o0 tee >(cksum >"$cksum_pipe" 2>/dev/null) | (
            # Sleep for 500ms to ensure that wl-paste --watch scripts are
            # triggered AFTER this script ends and rofi window closes
            sleep 0.5;
            wl-copy $PASTE_ONCE && ( sleep 30 && /usr/bin/wl-copy --clear) & disown
          )
      ) &>/dev/null & disown
      echo "Launched lpass show ... | wl-copy  pipeline subshell with PID $!" >&2
    else
      # Directly pipe the output to wl-copy if not copying sensitive data
      # shellcheck disable=SC2086
      lpass show --quiet -j "$1" | jq ".[0][\"$2\"]" -r | $process_newlines | wl-copy $PASTE_ONCE &
    fi
    wl_copy_pid="$!"

    if [ "$copying_sensitive_data" -eq 1 ]; then
      read -r cksum_output < "$cksum_pipe"
      rm -f "$cksum_pipe"
      pw_cksum_value=$(echo -n "$cksum_output" | cut -d ' ' -f 1)
      start-watch-clipboard "$pw_cksum_value" # TODO: Figure out if this is best place to start the clipboard watcher
      # update-progress-dialog '99'
    fi
    ;;
  esac

  [ "$copying_sensitive_data" -eq 1 ] && start-watch-clipboard "$pw_cksum_value"

  [ -n "$wl_copy_pid" ] && wait "$wl_copy_pid"

  [ -n "$CLIPBOARD_STATE" ] && unset CLIPBOARD_STATE
}

open-account-url() {
  local url
  url=$(lpass show --url "$1")
  if [[ -n "$url" ]]; then
    xdg-open "$url" >/dev/null 2>/dev/null
  else
    exit 2
  fi
}

is-actual-url() {
  local url="$1"
  if [[ -n "$url" && "$url" != " " && "$url" != "http://" && "$url" != "https://" ]]; then
    return 0
  else
    return 1
  fi
}

show-account-options() {
  local id="$1"

  # Find names of fields that aren't empty and aren't default fields.
  #TODO: Sort password and username first before all other fields!
  local fields
  mapfile -t fields < <(lpass show "$id" -j | jq '.[0] | map_values(select(. != "")) | keys | map(select(inside("id,name,fullname,last_modified_gmt,last_touch,group") | not))[]' -r)

  if "$CAN_TYPE"; then
    for field in "${fields[@]}"; do
      echo ">> Type $field [$id]"
    done
  fi

  for field in "${fields[@]}"; do
    echo ">> Copy $field [$id]"
  done

  url=$(lpass show --url "$id")
  if is-actual-url "$url"; then
    echo ">> Open $url [$id]"
  fi

  echo ">> Copy ID [$id]"
}

# This function works like `ifne` from `moreutils`
# It will pipe STDIN to the command passed as arguments if there is any input, otherwise it will do nothing
# @param command Command to run if there is any input
# @return 0 input not null (success), 1 input was null (failure)
ifne() {
  head=$(dd bs=1 count=1 2>/dev/null; echo -n a)
  head=${head%a}
  if [ "x$head" != x"" ]; then
    { printf '%s' "$head"; cat - ; } | "$@"
    return 0
  fi
  return 1
}

# Loop to show the account list and handle user input with wofi
# @discussion This function will loop until the user selects a null entry, this
# script produces no further output (e.g. some '>> ' prefixed option was chosen), or presses
# ESC
# @return 0 (success)
do-wofi-loop() {
  local choice
  choice=$(print-account-list | wofi --dmenu --width 1000 --height 1000 --lines 10 --prompt='Select an entry')
  while [ -n "$choice" ];  do
    choice=$($SELF_CMD "${choice:-}" | \
      ifne wofi --show dmenu \
        --matching=fuzzy \
        --insensitive \
        --prompt='Select an entry' \
    ) || break
  done
  return 0
}

is-entry-selected() {
  if [ -n "$*" ]; then
    return 0
  else
    return 1
  fi
}

id-in-selection() {
  echo "$1" | grep -oE '\[[0-9]+\]$' | tr -d '[]'
}

debug() {
  echo "$@" >/dev/stderr
}

if is-entry-selected "$1"; then
  selected="$1"

  id="$(id-in-selection "$selected" || echo -n '')"

  field=$(echo "$selected" | awk '{print $3}')

  if [[ -n "$id" ]]; then
    case "$selected" in
    '>> Copy ID'*)
      copy-account-field "$id" id
      ;;
    '>> Open'*)
      open-account-url "$id"
      ;;
    '>> Type '*)
      type-account-field "$id" "$field" &
      ;;
    '>> Copy '*)
      copy-account-field "$id" "$field"
      ;;
    *)
      show-account-options "$id"
      ;;
    esac
  else
    case "$selected" in
    'finalize-progress-dialog'*)
      trap 'kill-progress-dialog "$DIALOG_PID"' INT TERM HUP
      finalize-progress-dialog "$2" "$3" "$4" "$5"
      # dialog_pid progress_pid progress_fifo pw_cksum
      ;;
    'wofi-lpass'*)
      do-wofi-loop
      ;;
    *)
      echo "Could not detect the entry ID of \"${selected}\""
      echo "Unknown command \"${selected}\"" >&2
      exit 1
      ;;
    esac

    exit 0
  fi
else
  print-account-list
fi
