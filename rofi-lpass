#!/bin/bash
set -e
set -o pipefail
PS4='+ $(date "+%s.%N") (${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

SESSION_TYPE=x11
CAN_TYPE=false
if [[ -n "$WAYLAND_DISPLAY" ]]; then
  SESSION_TYPE=wayland
  export LPASS_CLIPBOARD_COMMAND=wl-copy
  if hash wtype; then
    CAN_TYPE=true
  fi
  # If wl-paste is running with cliphist, we should not use --paste-once and
  # instead show dialog window so that cliphist wrapper can avoid adding the
  # password to the history, based on the focused window title.
  if pgrep --list-full 'wl-paste' | grep -Eq '\--watch .*cliphist'; then
    PASTE_ONCE=''
    SHOW_DIALOG=1
  else
    # paste-once should work fine without a clipboard history manager
    PASTE_ONCE='--paste-once'
    SHOW_DIALOG=0
  fi
else
  if hash xvkbd || hash xdotool; then
    CAN_TYPE=true
  fi
fi

print-account-list() {
  lpass ls --format "%/as%ag - %an (%au) [%ai]" 2>&1
}

type-account-field() {
  # Close stdout and stderr to stop this process from dying when the parent ends
  exec 1>/dev/null 2>/dev/null

  local value
  value=$(lpass show --quiet -j "$1" | jq ".[0][\"$2\"]" -r)
  case "$SESSION_TYPE" in
  x11)
    if hash xvkbd 2>/dev/null; then
      xvkbd -xsendevent -text "$value"
    else
      local active_window
      active_window=$(xdotool getactivewindow)
      xdotool windowactivate --sync "$active_window" type --clearmodifiers "$value"
    fi
    ;;
  wayland)
    wtype "$value"
    ;;
  esac
}

# Initialize the progress dialog PID to 0
# Will be set by return value of show-progress-dialog if SHOW_DIALOG is set
DIALOG_PID=0

# kill-progress-dialog will kill the progress dialog and remove the FIFO if they still exist
# @param dialog_pid PID of the progress dialog
# @return 0 (success), 1 (failure)
kill-progress-dialog() {
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ]; then
    local dialog_pid="$1"
    if [ -n "$dialog_pid" ] && [ "$dialog_pid" -gt 1 ] && kill -0 "$dialog_pid" &>/dev/null; then
      kill "$dialog_pid" &>/dev/null || kill -9 "$dialog_pid" &>/dev/null
    fi
    [ -n "$PROGRESS_FIFO" ] && [ -p "$PROGRESS_FIFO" ] && rm -f "$PROGRESS_FIFO"
    [ -n "$PROGRESS_FIFO" ] && [[ "$(dirname "$PROGRESS_FIFO")" != '.' ]] && [ -d "$(dirname "$PROGRESS_FIFO")" ] && rmdir "$(dirname "$PROGRESS_FIFO")"
  fi
}

# Show a progress dialog while copying sensitive data to the clipboard
# @discussion This function will create a FIFO and progress dialog (via `yad`),
#   then write to it to update the progress dialog to 98% before returning it to
#   STDOUT.  The progress dialog will close itself after 5 seconds, when ESC is
#   pressed, when the window is unfocused, or when 100 is written to the FIFO.
# @output Progress dialog FIFO path, PID of the dialog process
#   (space-separated STDOUT)
# @return 0 (success), 1 (failure)
show-progress-dialog() {
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ]; then
    local progress_fifodir progress_pid progress_fifo
    progress_fifodir="$(mktemp -d /tmp/rofi-lpass.XXXXXXXXXX)" || {
      echo "Failed to create temp dir" >&2
      return 1
    }
    progress_fifo="$(mktemp -p "$progress_fifodir/" -u "yad-fifo.XXXXXXXXXX")" || {
      echo "Failed to create progress fifo" >&2
      return 1
    }
    mkfifo "$progress_fifo" || {
      echo "Failed to create progress fifo" >&2
      return 1
    }

    # Both should exit on their own, but return the PIDs just in case
    # The FIFO write will block unless there is a reader, so we need to run it
    # in the background
    (
      # Close stdout and stderr of this subshell to avoid waiting for any output
      exec 1>/dev/null 2>/dev/null

      # Setup a trap to cleanup the FIFO and temp dir when this subshell coprocess exits
      # This is a subshell, which didn't inherit the non-exported vars so we
      # need to set the variable for the trap handler
      # shellcheck disable=SC2030
      PROGRESS_FIFO="$progress_fifo"
      trap 'kill-progress-dialog "$DIALOG_PID"' INT TERM HUP EXIT

      tail -f "$progress_fifo" |
        yad --progress --icon=lock \
          --title='rofi-lpass: Added sensitive text to clipboard' \
          --text='Adding sensitive info to clipboard' \
          --image=lock --buttons-layout=center --escape-ok \
          --progress-text='Copying: ' --auto-close --align=center --text-align=center
    ) &
    dialog_pid="$!"
    disown $dialog_pid

    (
      echo "BEGIN: for loop writing to FIFO" >&2
      exec 1>/dev/null 2>/dev/null
      for i in $(seq 1 98); do
        stdbuf -oL echo "$i"
        sleep 0.002
      done >"$progress_fifo"
    ) &
    progress_pid="$!"
    disown $progress_pid

    echo -n "$progress_fifo $dialog_pid $progress_pid" >&1
    return 0
  fi
  return 1
}

# Start a background process to watch the clipboard for the password
# and close the dialog when it is found
# @param pw_cksum CRC of the password to be shielded by the dialog window
# @return 0 (success), 1 (failure)
# @discussion This function starts a background wl-paste process to watch the
# clipboard, and launch this script with the finalize-progress-dialog function.
# That function will close the dialog when a checksum of the password we expect
# is found to match the clipboard contents.
start-watch-clipboard() {
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ]; then
    local me pw_cksum
    me="$(realpath "$0")" # Path of this script
    pw_cksum="$1"
    # Start a background process to watch the clipboard for the password
    # and close the dialog when it is found
    # This should ensure that the dialog lives long enough to shield the
    # password from cliphist
    (
      echo "BEGIN: start-watch-clipboard" >&2
      exec 1>/dev/null 2>/dev/null
      # Attempt to export the global variables to the subshell, assuming the trap will access these
      export DIALOG_PID="$DIALOG_PID"
      export PROGRESS_PID="$PROGRESS_PID"
      export PROGRESS_FIFO="$PROGRESS_FIFO"
      # shellcheck disable=SC2064
      # Eval $DIALOG_PID now, because the subshell will not have it set
      # We want to cleanup the dialog and FIFO when the wl-paste and thus
      # subshell fork process is killed
      trap "kill-progress-dialog '$DIALOG_PID'" INT TERM HUP
      # wl-paste --watch 'sleep 1; stdbuf -oL echo 100 > $PROGRESS_FIFO'
      # finalize-progress-dialog(dialog_pid, progress_pid, progress_fifo, ppid_fifo, pw_cksum)

      # Note: We are re-entrant here, but all global variable state is lost in the new shell,
      # so we need to pass them as arguments
      wl-paste --watch "$me" finalize-progress-dialog "$DIALOG_PID" "$PROGRESS_PID" "$PROGRESS_FIFO" "$pw_cksum" 1>&2 2>>/tmp/rofi-lpass-wl-paste-watch.log
    ) &
    self_fork_pid="$!"
    disown $self_fork_pid
    echo "Started wl-paste --watch in subshell with PID $self_fork_pid" >&2
    return 0
  fi
  return 1
}

# Update the progress dialog with a new value
update-progress-dialog() {
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ]; then
    local new_value
    new_value="$1"
    echo "Updating progress dialog to $new_value" >&2
    if kill -0 "$PROGRESS_PID" 2>/dev/null; then
      echo "BEFORE writing '$new_value' - KILLING Progress PID $PROGRESS_PID !!" >&2
      kill "$PROGRESS_PID" 2>/dev/null || kill -9 "$PROGRESS_PID" 2>/dev/null || true
    fi

    stdbuf -oL echo "$new_value" >"$PROGRESS_FIFO"
  fi
}

# Close the progress dialog by updating it to 100%
# To be run by wl-paste --watch after the password is in the clipboard
# @param dialog_pid PID of the progress dialog
# @param progress_pid PID of the progress dialog's progress writer
# @param progress_fifo Path to the progress dialog's FIFO
# @param pw_cksum CRC of the password to be shielded by the dialog window
# @return 0 (success), 1 (failure)
# @discussion This function will check that the password found in clipboard
# matches the one we just copied, then sleep for a moment and update the
# progress dialog to 100%
finalize-progress-dialog() {
  local dialog_pid progress_pid progress_fifo pw_cksum ppid
  dialog_pid="$1"
  progress_pid="$2"
  progress_fifo="$3"
  pw_cksum="${*:4}"

  # Get the parent PID of this script, should be the PID of: wl-paste --watch
  ppid="$(ps -o ppid= -p "$$" | awk '{ print $1 }' )"
  ps -o cmd -p "$ppid" | grep -q 'wl-paste --watch' || {
    echo "Not running in wl-paste --watch, exiting" >&2
    return 1
  }

  # Process the entire STDIN stream with cksum and store the output
  cksum_output=$(cat - | cksum 2>/dev/null)

  # Extract the cksum value
  cksum_value=$(echo "$cksum_output" | cut -d ' ' -f 1)

  echo "Given Password Checksum: $pw_cksum" >&2
  echo "wl-paste output cksum: $cksum_output" >&2
  echo "wl-paste cksum value: $cksum_value" >&2

  echo "Checking clipboard for password match: $pw_cksum == $cksum_value ?" >&2
  if [[ "$pw_cksum" == "$cksum_value" ]]; then
    echo "Checksum match found" >&2
    # Wait for the cliphist store wrapper script to end
    # This will ensure that the dialog is closed after the password is in the clipboard
    while ! cliphist_pid=$(pgrep --full '^bash.*\.local/share/sway/scripts/cliphist store' 2>/dev/null) ; do
      # Waiting for cliphist store to start
      sleep 0.001
      # TODO: Add a timeout here... if cliphist store does not start, we will be
      # stuck running forever
    done
    # Wait for cliphist store to end
    inotifywait --event CLOSE "/proc/$cliphist_pid/fd/0"

    sleep 1 # Wait slightly after cliphist store to see the focused dialog window
    # Set global variables to cleanup the dialog & background processes
    # This function is only run by wl-paste --watch, in a separate shell process
    # so we need to set these
    PROGRESS_FIFO="$progress_fifo"
    PROGRESS_PID="$progress_pid"
    DIALOG_PID="$dialog_pid"
    SHOW_DIALOG=1

    # Update the progress dialog to 100% to close it
    echo "Updating progress dialog to 100%" >&2
    update-progress-dialog '100'

    # Cleanup the dialog and FIFO
    [ "$DIALOG_PID" -ne 0 ] && kill-progress-dialog "$DIALOG_PID"
    # We are the last process in the chain, so we need to kill the parent
    # The parent process of this script, is the `wl-paste --watch` process
    [ -n "$ppid" ] && [ "$ppid" -gt 1 ] && kill "$ppid" 2>/dev/null || kill -9 "$ppid" 2>/dev/null || true
    return 0
  else
    echo "No checksum match found" >&2
    # Avoid killing the dialog, and cleaning up the FIFO because we have not
    # found the password in the clipboard this time
    DIALOG_PID=0
    PROGRESS_FIFO=''
    return 1
  fi

}

copy-account-field() {
  echo "BEGIN copy-account-field" >&2
  local wl_copy_pid show_dialog_output copying_sensitive_data

  # Initialize to 0
  copying_sensitive_data=0

  # Note: This does not do anything with wl-copy, but we will use it anyway in
  # case it supports this in the future
  if [[ "${2}" =~ "password" ]]; then
    export CLIPBOARD_STATE=sensitive
  fi

  # Only show progress / "security screen" dialog if copying a password AND SHOW_DIALOG is set
  # Effectively, this will only show the dialog if copying a password AND on Wayland with cliphist running
  # For example with: wl-paste --watch cliphist store
  if [ -n "$SHOW_DIALOG" ] && [ "$SHOW_DIALOG" -eq 1 ] && [ -n "$CLIPBOARD_STATE" ] && [ "$CLIPBOARD_STATE" == "sensitive" ]; then
    copying_sensitive_data=1
  fi

  if [ "$copying_sensitive_data" -eq 1 ]; then
    # Capture the output from show-progress-dialog
    show_dialog_output="$(show-progress-dialog)"
    PROGRESS_FIFO="$(echo -n "$show_dialog_output" | cut -d' ' -f1)"
    DIALOG_PID="$(echo -n "$show_dialog_output" | cut -d ' ' -f2)"
    PROGRESS_PID="$(echo -n "$show_dialog_output" | cut -d ' ' -f3)"

    # Now you have both the FIFO path and PID captured
    echo "FIFO Path: $PROGRESS_FIFO" >&2
    echo "Dialog PID: $DIALOG_PID" >&2
    echo "Progress PID: $PROGRESS_PID" >&2
  fi

  case "$SESSION_TYPE" in
  x11)
    lpass show --quiet -j "$1" | jq ".[0][\"$2\"]" -r | tr -d '\n' | xsel -ib -t 30000
    ;;
  wayland)
    if [ "$copying_sensitive_data" -eq 1 ]; then
      # Create a named pipe for cksum output, only stored in SHM virtual in-memory filesystem
      cksum_pipe_pattern="/dev/shm/cksum_pipe.$$.XXXXXXXXX"
      cksum_pipe="$(mktemp -u "$cksum_pipe_pattern")"
      mkfifo "$cksum_pipe"

      # Use tee to send a copy of the output to cksum, processed through the named
      # pipe.  This will allow us to never store the password in a variable, and
      # only use the fast CRC checksum to compare the expected values in the
      # coprocess spawned by wl-paste --watch running the finalize-progress-dialog
      # function.
      # Directly include the tee command in the pipeline when copying sensitive data
      # shellcheck disable=SC2086
      lpass show --quiet -j "$1" | jq ".[0][\"$2\"]" -r | tr -d '\n' | stdbuf -o0 tee >(cksum >"$cksum_pipe" 2>/dev/null) | wl-copy $PASTE_ONCE &
    else
      # Directly pipe the output to wl-copy if not copying sensitive data
      # shellcheck disable=SC2086
      lpass show --quiet -j "$1" | jq ".[0][\"$2\"]" -r | tr -d '\n' | wl-copy $PASTE_ONCE &
    fi
    wl_copy_pid="$!"

    if [ "$copying_sensitive_data" -eq 1 ]; then
      read -r cksum_output < "$cksum_pipe"
      rm -f "$cksum_pipe"
      pw_cksum_value=$(echo -n "$cksum_output" | cut -d ' ' -f 1)
      start-watch-clipboard "$pw_cksum_value" # TODO: Figure out if this is best place to start the clipboard watcher
      update-progress-dialog '99'
    fi
    ;;
  esac

  [ "$copying_sensitive_data" -eq 1 ] && start-watch-clipboard "$pw_cksum_value"

  [ -n "$wl_copy_pid" ] && wait "$wl_copy_pid"

  [ -n "$CLIPBOARD_STATE" ] && unset CLIPBOARD_STATE
}

open-account-url() {
  local url
  url=$(lpass show --url "$1")
  if [[ -n "$url" ]]; then
    xdg-open "$url" >/dev/null 2>/dev/null
  else
    exit 2
  fi
}

is-actual-url() {
  local url="$1"
  if [[ -n "$url" && "$url" != " " && "$url" != "http://" && "$url" != "https://" ]]; then
    return 0
  else
    return 1
  fi
}

show-account-options() {
  local id="$1"

  # Find names of fields that aren't empty and aren't default fields.
  #TODO: Sort password and username first before all other fields!
  local fields
  mapfile -t fields < <(lpass show "$id" -j | jq '.[0] | map_values(select(. != "")) | keys | map(select(inside("id,name,fullname,last_modified_gmt,last_touch,group") | not))[]' -r)

  if "$CAN_TYPE"; then
    for field in "${fields[@]}"; do
      echo ">> Type $field [$id]"
    done
  fi

  for field in "${fields[@]}"; do
    echo ">> Copy $field [$id]"
  done

  url=$(lpass show --url "$id")
  if is-actual-url "$url"; then
    echo ">> Open $url [$id]"
  fi

  echo ">> Copy ID [$id]"
}

is-entry-selected() {
  if [ -n "$*" ]; then
    return 0
  else
    return 1
  fi
}

id-in-selection() {
  echo "$1" | grep -oE '\[[0-9]+\]$' | tr -d '[]'
}

debug() {
  echo "$@" >/dev/stderr
}

if is-entry-selected "$1"; then
  selected="$1"

  id="$(id-in-selection "$selected" || echo -n '')"

  field=$(echo "$selected" | awk '{print $3}')

  if [[ -n "$id" ]]; then
    case "$selected" in
    '>> Copy ID'*)
      copy-account-field "$id" id
      ;;
    '>> Open'*)
      open-account-url "$id"
      ;;
    '>> Type '*)
      type-account-field "$id" "$field" &
      ;;
    '>> Copy '*)
      copy-account-field "$id" "$field"
      ;;
    *)
      show-account-options "$id"
      ;;
    esac
  else
    case "$selected" in
    'finalize-progress-dialog'*)
      trap 'kill-progress-dialog "$DIALOG_PID"' INT TERM HUP
      finalize-progress-dialog "$2" "$3" "$4" "$5"
      # dialog_pid progress_pid progress_fifo pw_cksum
      ;;
    *)
      echo "Could not detect the entry ID of \"${selected}\""
      echo "Unknown command \"${selected}\"" >&2
      exit 1
      ;;
    esac

    exit 0
  fi
else
  print-account-list
fi
